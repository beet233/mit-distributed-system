# ZooKeeper 与一致性模型

## 一致性模型的用处

> **数据复制主要的目的有两个：可用性和性能。**首先数据复制可以提高系统的可用性。在保持多副本的情况，有一个副本不可用，系统切换到其他副本就会恢复。常用的 MySQL 主备同步方案就是一个典型的例子。另一方面，数据复制能够提供系统的性能。当分布式系统需要在服务器数量和地理区域上进行扩展时，数据复制是一个相当重要的手段。有了多个数据副本，就能将请求分流；在多个区域提供服务时，也能通过就近原则提高客户端访问数据的效率。常用的 CDN 技术就是一个典型的例子。
> 但是数据复制是要付出代价的。**数据复制带来了多副本数据一致性的问题。**一个副本的数据更新之后，其他副本必须要保持同步，否则数据不一致就可能导致业务出现问题。因此，每次更新数据对所有副本进行修改的时间以及方式决定了复制代价的大小。全局同步与性能实际上是矛盾的，而为了提高性能，往往会采用放宽一致性要求的方法。因此，**我们需要用一致性模型来理解和推理在分布式系统中数据复制需要考虑的问题和基本假设。**

## 一致性模型分类

### 强一致性模型

**能够保证所有进程对数据的读写顺序都保持一致**的一致性模型称为**强一致性模型**。

#### 顺序一致性（Sequential Consistency）

两个约束：

- 单个节点的事件历史在全局历史上符合程序的先后顺序。
- 全局事件历史在各个节点上一致。

我们可以根据这两个约束来判断一个系统是否满足顺序一致性：如果在系统中找不到任何一个符合上述两个约束的**全局事件历史**，则说明该系统一定不满足顺序一致性；如果能找到一个符合上述两个约束的全局事件历史，这说明系统在这段过程内是满足顺序一致性的。

看起来比较抽象，例子如下：

> 假设分布式系统存在A、B、C三个节点，初始值x=0、y=0，各个节点上发生的事件如图所示。
>
> ![img](https://beetpic.oss-cn-hangzhou.aliyuncs.com/img/202211261616471.jpeg)
>
> 我们发现 B2 读到 y=3，那么在全局历史中 B2 在 A2 之后，而 B3 读出 x=0，那么在全局历史中 B3 在 A1 之前，但是在节点 A 的历史中，A1 在 A2 之前，在节点 B 的历史中，B2 在 B3 之前，这样子就不存在一个全局历史排列，能够将 A1、A2、B2、B3 排列起来，并且满足节点内历史的要求。所以这个情况不满足顺序一致性。
>
> 下面再展示一个满足顺序一致性的：
>
> ![img](https://beetpic.oss-cn-hangzhou.aliyuncs.com/img/202211261620952.jpeg)
>
> 在上图中，我们能够找到满足以上约束的全局历史，例如：
>
> - B1-B2-A1-B3-A2-C1-C2
> - B1-A1-B2-B3-A2-C1-C2
> - B1-A1-C1-B2-A2-C2-B3
> - ……
>
> 这样的全局历史还可以找出很多，这意味着目前的这些片段是满足顺序一致性的。而如果一个系统的工作中，其全部事件都能满足顺序一致性，那这个系统就满足顺序一致性。

#### 线性一致性（Linearizable Consistency）

线性一致性也叫严格一致性（Strict Consistency）或者原子一致性（Atomic Consistency），它的条件是：

+ 任何一次读都能读取到某个数据最近的一次写的数据。

+ 所有进程看到的操作顺序都跟**全局时钟**下的顺序一致。

线性一致性是对一致性要求最高的一致性模型，就现有技术是不可能实现的。因为它要求所有操作都实时同步，在分布式系统中要做到全局完全一致时钟现有技术是做不到的。首先通信是必然有延迟的，一旦有延迟，时钟的同步就没法做到一致。

当你只有一些写操作时，很难判断线性一致，因为你没有任何证据证明系统实际做了哪些操作，或者存储了什么数据，所以（在判断线性一致时）我们必须要有一些读操作。

我们一直在用一些历史记录来判断是不是具有顺序一致性或者线性一致性，因为这是关于系统行为的定义。我们需要从系统的输出来判断它是不是满足这样的准则。

在设计系统的时候，没有一个方法能将系统设计成线性一致。除非在一个非常简单的系统中，你只有一个服务器，一份数据拷贝，并且没有运行多线程，没有使用多核，在这样一个非常简单的系统中，要想违反线性一致还有点难。但是在任何分布式系统中，又是非常容易违反线性一致性。

### 弱一致性模型

不能保证所有进程对数据的读写顺序都保持一致的一致性模型称为**弱一致性模型**。

#### 因果一致性（Causal Consistency）

因果一致性是一种弱化的顺序一致性模型，因为它将具有潜在因果关系的事件和没有因果关系的事件区分开了。那么什么是因果关系？如果事件 B 是由事件 A 引起的或者受事件 A 的影响，那么这两个事件就具有因果关系。
举个分布式数据库的示例，假设进程 P1 对数据项 x 进行了写操作，然后进程 P2 先读取了 x，然后对 y 进行了写操作，那么对 x 的读操作和对 y 的写操作就具有潜在的因果关系，因为 y 的计算可能依赖于 P2 读取到 x 的值（也就是 P1 写的值）。
另一方面，如果两个进程同时对两个不同的数据项进行写操作，那么这两个事件就不具备因果关系。无因果关系的操作称为并发操作。

两个约束：

+ 所有进程必须以相同的顺序看到具有因果关系的读写操作。
+ 不同进程可以以不同的顺序看到并发的读写操作。

因果一致性是一种弱化的顺序一致性模型。顺序一致性虽然不保证事件发生的顺序跟实际发生的保持一致，但是它能够保证所有进程看到的读写操作顺序是一样的。而**因果一致性更进一步弱化了顺序一致性中对读写操作顺序的约束，仅保证有因果关系的读写操作有序，没有因果关系的读写操作（并发事件）则不做保证。**也就是说如果是无因果关系的数据操作不同进程看到的值是有可能是不一样，而有因果关系的数据操作不同进程看到的值保证是一样的。

#### 最终一致性（Eventual Consistency）

最终一致性是更加弱化的一致性模型，因果一致性起码还保证了有因果关系的数据不同进程读取到的值保证是一样的，而**最终一致性只保证所有副本的数据最终在某个时刻会保持一致。**
从某种意义上讲，最终一致性保证的数据在某个时刻会最终保持一致就像是在说：“人总有一天会死”一样。实际上我们更加关心的是：

**1. “最终”到底是多久？通常来说，实际运行的系统需要能够保证提供一个有下限的时间范围。**

**2. 多副本之间对数据更新采用什么样的策略？一段时间内可能数据可能多次更新，到底以哪个数据为准？一个常用的数据更新策略就是以时间戳最新的数据为准。**

由于最终一致性对数据一致性的要求比较低，在对性能要求高的场景中是经常使用的一致性模型。

#### 以客户端为中心的一致性（Client-centric Consistency）

前面我们讨论的一致性模型都是针对数据存储的多副本之间如何做到一致性，考虑这么一种场景：在最终一致性的模型中，如果客户端在数据不同步的时间窗口内访问不同的副本的同一个数据，会出现读取同一个数据却得到不同的值的情况。为了解决这个问题，有人提出了以客户端为中心的一致性模型。**以客户端为中心的一致性为单一客户端提供一致性保证，保证该客户端对数据存储的访问的一致性，但是它不为不同客户端的并发访问提供任何一致性保证。**
举个例子：客户端 A 在副本 M 上读取 x 的最新值为 1，假设副本 M 挂了，客户端 A 连接到副本 N 上，此时副本 N 上面的 x 值为旧版本的 0，那么一致性模型会保证客户端 A 读取到的 x 的值为 1，而不是旧版本的 0。一种可行的方案就是给数据 x 加版本标记，同时客户端 A 会缓存 x 的值，通过比较版本来识别数据的新旧，保证客户端不会读取到旧的值。

以客户端为中心的一致性包含了四种子模型：

**1. 单调读一致性（Monotonic-read Consistency）**：如果一个进程读取数据项 x 的值，那么该进程对于 x 后续的所有读操作要么读取到第一次读取的值要么读取到更新的值。即保证客户端不会读取到旧值。
**2. 单调写一致性（Monotonic-write Consistency）**：一个进程对数据项 x 的写操作必须在该进程对 x 执行任何后续写操作之前完成。即保证客户端的写操作是串行的。
**3. 读写一致性（Read-your-writes Consistency）**：一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见。即保证客户端能读到自己最新写入的值。
**4. 写读一致性（Writes-follow-reads Consistency）**：同一个进程对数据项 x 执行的读操作之后的写操作，保证发生在与 x 读取值相同或比之更新的值上。即保证客户端对一个数据项的写操作是基于该客户端最新读取的值。

## What about Raft?

在讨论分布式系统时，共识算法（Consensus algorithm）和一致性（Consistency）通常是讨论热点，两者的联系很微妙，很容易搞混。一些常见的误解：使用了 Raft 或者 paxos 的系统都是线性一致的（Linearizability，即强一致），其实不然，共识算法只能提供基础，要实现线性一致还需要在算法之上做出更多的努力。以 TiKV 为例，它的共识算法是 Raft，在 Raft 的保证下，TiKV 提供了满足线性一致性的服务。

一个分布式系统正确实现了共识算法并不意味着能线性一致。共识算法只能保证多个节点对某个对象的状态是一致的，以 Raft 为例，它只能保证不同节点对 Raft Log（以下简称 Log）能达成一致。那么 Log 后面的状态机（state machine）的一致性呢？并没有做详细规定，用户可以自由实现。

[线性一致性和 Raft - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/47117804) TiKV 和 6.824 的 lab3 还是比较相似的，并且有一些优化，可以研究研究。

## 参考

[分布式系统：一致性模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/59119088?utm_id=0)

[什么是顺序一致性？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/527494829)

[详解分布式协调服务 ZooKeeper，再也不怕面试问这个了 (qq.com)](https://mp.weixin.qq.com/s/DwyPt5YZgqE0O0HYEC1ZMQ)

[8.5 一致保证（Consistency Guarantees） - MIT6.824 (gitbook.io)](https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/lecture-08-zookeeper/8.5)

[分布式系统协议Paxos、Raft和ZAB - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/147691282)